<!DOCTYPE html>
<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="UTF-8">
    <title>DNA</title>
</head>

<body>
    <style>
        html {
            line-height: 1.4;
            -webkit-text-size-adjust: 100%;
        }

        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            overflow: hidden;
        }

        canvas {
            height: 100vh;
            width: 100vw;
            position: fixed;
            top: 0;
            left: 0;
        }
    </style>
    <script type="text/javascript">
        const SAMPLE_RATIO = 1;
        window.addEventListener('load', function () {
            const canvas = document.querySelector("canvas");
            let view = canvas.getBoundingClientRect();
            let mpos = { x: 0, y: 0 };
            canvas.width = view.width * SAMPLE_RATIO;
            canvas.height = view.height * SAMPLE_RATIO;
            const gl = canvas.getContext("webgl");
            if (gl === null) {
                alert("Unable to initialize WebGL. Your browser may not support it.");
                return;
            }

            gl.clearColor(0.0, 0.0, 0.0, 0.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            fetch('/frag.glsl')
                .then(function (response) {
                    return response.text();
                })
                .then(function (shader) {
                    const frag = gl.createShader(gl.FRAGMENT_SHADER);
                    gl.shaderSource(frag, shader);
                    gl.compileShader(frag);
                    if (!gl.getShaderParameter(frag, gl.COMPILE_STATUS)) {
                        alert(gl.getShaderInfoLog(frag));
                        return null;
                    }
                    const vert = gl.createShader(gl.VERTEX_SHADER);
                    gl.shaderSource(vert, `#version 100
                        attribute vec4 aVertexPosition;
                        void main() {
                            gl_Position = aVertexPosition;
                        }
                    `);
                    gl.compileShader(vert);
                    if (!gl.getShaderParameter(vert, gl.COMPILE_STATUS)) {
                        alert(gl.getShaderInfoLog(vert));
                        return null;
                    }
                    const program = gl.createProgram();
                    gl.attachShader(program, vert);
                    gl.attachShader(program, frag);
                    gl.linkProgram(program);
                    const vertices = new Float32Array([1, -1, 0, 1, 1, 0, -1, -1, 0, -1, 1, 0]);
                    const vbo = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
                    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
                    let loc = gl.getAttribLocation(program, 'aVertexPosition');
                    let res = gl.getUniformLocation(program, 'res');
                    let mloc = gl.getUniformLocation(program, 'mpos');
                    let texture = gl.createTexture();
                    let sequenceTexture = gl.getUniformLocation(program, 'sequenceTexture');
                    let sequenceLength = gl.getUniformLocation(program, 'sequenceLength');
                    gl.vertexAttribPointer(loc, 3, gl.FLOAT, false, 0, 0);
                    gl.enableVertexAttribArray(loc);

                    window.addEventListener('mousemove', (e) => {
                        mpos.x = e.x / view.width;
                        mpos.y = e.y / view.height;
                    });

                    window.addEventListener('resize', () => {
                        view = canvas.getBoundingClientRect();
                        canvas.width = view.width * SAMPLE_RATIO;
                        canvas.height = view.height * SAMPLE_RATIO
                    });

                    let sequenceArray = Uint8Array.from([10, 200, 255, 0]);
                    console.log(sequenceArray);
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.ALPHA, sequenceArray.length, 1, 0, gl.ALPHA, gl.UNSIGNED_BYTE, sequenceArray);

                    const draw = () => {
                        gl.viewport(0, 0, view.width * SAMPLE_RATIO, view.height * SAMPLE_RATIO);
                        gl.clear(gl.COLOR_BUFFER_BIT);
                        gl.useProgram(program);
                        gl.uniform2f(res, view.width * SAMPLE_RATIO, view.height * SAMPLE_RATIO);
                        gl.uniform2f(mloc, mpos.x, mpos.y);
                        gl.uniform1i(sequenceLength, sequenceArray.length);
                        gl.uniform1i(sequenceTexture, 0);
                        gl.bindTexture(gl.TEXTURE_2D, texture);
                        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                        window.requestAnimationFrame(draw);
                    };

                    window.requestAnimationFrame(draw);
                });
        })
    </script>
    <canvas></canvas>
</body>

</html>